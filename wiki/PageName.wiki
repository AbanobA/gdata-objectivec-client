#summary GData Objective-C Client Framework Design Document

== Document Audience ==

The audience for this document is developers who will be maintaining
or extending the GData Objective-C Client Framework.

Readers should already be familiar with the introductory document GDataObjCIntroduction.

== Project Goals ==

The GData framework is intended to make it easy for Cocoa applications to interact with Google services.

The framework handles parsing and generation of XML, http network transactions, and authentication (account sign-in).

The framework does not provide user-interface, but the object interfaces should work smoothly with KVC and Cocoa bindings.

The framework relies on AppKit's NSXMLDocument for parsing and generating XML text. Internally, the framework builds GData objects from trees of NSXMLNodes, and generates trees of NSXMLNodes.

== Framework Objects ==

The framework defines these kinds of objects:

  * Elements, which can be created by or generate XML.  Elements include
    * Entries, derived from GDataEntryBase
    * Feeds, derived from GDataFeedBase, containing lists of entries
    * Individual data types, which may optionally be usable as extensions

  * Data-type helpers, such as GDataDateTime

  * Services, which handle sign-in and networking
    * Service tickets, which track server requests and responses

  * Queries, which provide a convenient way to create request URLs

== GDataObjects ==

Objects in the framework which parse or generate XML are derived from the base class GDataObject.  Each subclass of GDataObject should implement these methods:

{{{
- (id)initWithXMLElement:(NSXMLElement *)element
                  parent:(GDataObject *)parent; // parses the XML
- (NSXMLElement *)XMLElement; // generates the XML; should begin by calling GDataObject's XMLElementWithExtensionsAndDefaultName
}}}
along with these usual NSObject methods,
{{{
- (id)copyWithZone:(NSZone *)zone; (be sure to call superclass)
- (BOOL)isEqual:(GDataObject *)other; (be sure to call superclass)
- (NSString *)description; // entries and feeds may implement -itemsForDescription instead
}}}

GDataObjects contain no XML data (that is, they retain no XML nodes from the parse tree) _except_ for any unknown elements and attributes.  Unknown elements and attributes are the data which was not recognized during GData parsing of the XML tree.

== Contents of the GDataObject base class ==

The GDataObject base class manages many kinds of data for each instance.  To preserve this data, derived classes must call into the base class

  * Element name
  The element's qualified name is saved from the original parsed XML, and reused during XML generation.  Extensions also declare a default element name for use in objects which were not initialzed from XML.
  
  * Parent
  The parent object in the GData hierarchy is used only when looking for appropriate extension class declarations during parsing.  It may be nil.

  * Namespaces
  Namespaces are stored as an NSDictionary of mappings from prefix (like "gd") to URI (like "!http://schemas.google.com/g/2005").  At a minimum, the root GData element must declare appropriate namespaces for its XMLElement method to generate an XML tree.

  * Extension declarations
  Each GData object can specify a list of allowable extensions for itself and its descendant elements.  See "The Extension Model" below for more detail.

  * Extension instances
  Operations on extension instances (creation during XML parsing, XML generation, copying, comparison) are handled automatically by GDataObject for subclasses, so long as the subclasses call the needed superclasses.

  * Unknown elements and unknown attributes
  At the outset of parsing the XML tree, all of an element's child elements and attributes are added to lists of unknown XMLNodes.  The XMLNodes are removed from the lists of unknowns as they are parsed.  Any remaining NSXMLNodes remaining in the lists of unknowns are retained, and re-added during XML generation. 

  * User data
  The userData field is available for client use.  It is retained by the GDataObject but otherwise ignored.

The GDataObject base class includes a wide variety of methods for these tasks:
  * Typical NSObject methods (copyWithZone, isEqual, setters, getters, and so on)
  * XML tree parsing
  * XML tree generation
  * Extension element management
  * Dynamic object class identification (see "Dynamic Object Generation" below)

== The Extension Model ==
Extensions enable an element to contain children about which the element
may know no details.

Typically, entries add extensions to themselves. For example, during initialization, a calendar
entry declares it may contain a color:
{{{
[self addExtensionDeclarationForParentClass:[GDataEntryCalendar class]
                                 childClass:[GDataColorProperty class]];
}}}
This lets the base class handle much of the work of managing the child
element.  The calendar entry can still provide accessor methods to get
to the extension by calling into the base class, as in
{{{
- (GDataColorProperty *)color {
  return (GDataColorProperty *) 
    [self objectForExtensionClass:[GDataColorProperty class]];
}

- (void)setColor:(GDataColorProperty *)val {
  [self setObject:val forExtensionClass:[GDataColorProperty class]];
}
}}}
The real purpose of extensions is to allow elements to contain children
they may not know about.  For example, a !CalendarEventEntry declares
that GDataLinks contained within the calendar event entry may contain
GDataWebContent elements:
{{{
[self addExtensionDeclarationForParentClass:[GDataLink class]
                                 childClass:[GDataWebContent class]];  
}}}
The !CalendarEvent has extended GDataLinks without GDataLinks knowing or
caring.  Because GDataLink derives from GDataObject, the GDataLink
object will automatically parse and maintain and copy and compare
the GDataWebContents contained within.

Typically, elements that declare extensions for themselves will also have accessors for those extensions, such as the `color:` and `setColor:` methods shown above.


The GDataObject base class tracks parents for each object to enable it to look during parsing at the extensions declared higher up the object tree.

== Dynamic Object Generation ==

Parsing XML requires knowing what kind of objects to create for that XML.  Typically, the class of a feed object will be known by the Service object fetching it.  For example, the calendar service class fetches a calendar by specifying the class of the feed, !GDataFeedCalendar:

{{{
- (GDataServiceTicket *)fetchCalendarFeedWithURL:(NSURL *)feedURL
                                        delegate:(id)delegate
                               didFinishSelector:(SEL)finishedSelector
                                 didFailSelector:(SEL)failedSelector {
  
  return [self fetchAuthenticatedFeedWithURL:feedURL 
                                   feedClass:[GDataFeedCalendar class]
                                    delegate:delegate
                           didFinishSelector:finishedSelector
                             didFailSelector:failedSelector];
}
}}} 

Similarly, the feed class will specify the class of the entries to be created for it. Naturally, the calendar feed class expects calendar entries:

{{{
- (Class)classForEntries {
  return [GDataEntryCalendar class];
}
}}}

Sometimes, XML parsing is done without knowing in advance what the class of the XML object should be.  This happens when a service method may be used to retrieve multiple classes of objects, or when an XML feed or entry is embedded inside of an element.

To identify dynamically what class to use to parse XML when no class is specified, GDataObject uses [http://developer.apple.com/documentation/Cocoa/Conceptual/NSXML_Concepts/Articles/QueryingXML.html XPath] to inspect [http://code.google.com/apis/gdata/elements.html#Introduction category] child elements in the XML. Feed and entry classes can register in their 
+[http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/load load] methods what scheme and/or term attribute values matches identify XML which can be parsed by the class. A spreadsheet cell class registers itself this way:
{{{
+ (void)load {
  [GDataObject registerEntryClass:[self class]
            forCategoryWithScheme:nil 
                             term:@"http://schemas.google.com/spreadsheets/2006#cell"];
}
}}}


 

== Deconstructing an Example Object: GDataTextConstruct ==

== Service Classes ==

== Query Classes ==










