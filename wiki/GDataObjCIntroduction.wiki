#summary Introduction for Objective-C Developers
#labels Featured

= Introduction to Google Data APIs for Cocoa Developers =

[http://code.google.com/apis/gdata/index.html Google Data APIs] allow client software to access and manipulate data hosted by Google services.

The Google Data APIs Objective-C Client Library is a Mac OS X framework that enables developers for Mac OS X to easily write native Cocoa applications.  The framework handles

  * XML parsing and generation
  * Networking
  * Sign-in for Google accounts
  * Service-specific protocols and query generation


== Requirements ==

The Google Data APIs Objective-C Client Library requires Mac OS X 10.4 due to dependencies on NSXMLDocument.

== Example Applications ==

The Examples directory contains example applications showing typical interactions with Google services using the framework.  The applications act as simple browsers for the structure of feed and entry classes for each service.  The !WindowController source files of the samples were written with typical Cocoa idioms to serve as quick introductions to use of the APIs.  

== Adding Google Data APIs to a project ==

The Google Data APIs Objective-C Client Library is provided as a built framework, suitable for inclusion in a Cocoa application bundle's Frameworks folder.  To add the framework to an Xcode project, drag GData.framework to the project's Linked Frameworks source group, then drag the GData framework from the  Linked Frameworks group folder to the Link Binary With Library phase inside of the application target.  

Source files referring to GData objects should include the GData headers as 

`#import "GData/GData.h"`

The GData source code and the project for building the framework is also provided. To facilitate debugging, you may opt to include the GData.xcode project or the GData source files directly in your application project.  The example applications show how to include a reference to the GData framework project file in your Xcode project.


== Google Data APIs Basics ==

Servers respond to client GData requests with *feeds* that include lists of *entries*. For example, a request for all of a user's calendars would return a Calendar feed with a list of entries, where each entry represents one calendar.  A request for all events in one calendar would return a Calendar Event feed with a list of entries, with each entry representing one of the user's scheduled events.

Each feed and entry is composed of *elements*.  Elements represent either standard Atom XML elements, or custom-defined GData elements.

Feeds, entries, and elements are derived from *GDataObject*, the base class that implements XML parsing and generation.

Google web application interactions are handled by *service objects*.  A single transaction with a service is tracked with a *service ticket*.

For example, here is how to use the Google Calendar service to retrieve a feed of calendar entries, where each entry describes one of the user's calendars.
{{{
  service = [[GDataServiceGoogleCalendar alloc] init];
    
  [service setUserAgent:@"MyCalendarApp"];
  [service setUserCredentialsWithUsername:username
                                 password:password];

  GDataServiceTicket *ticket;
  ticket = [service fetchCalendarFeedForUsername:username
                                        delegate:self
                               didFinishSelector:@selector(ticket:finishedWithFeed:)
                                 didFailSelector:@selector(ticket:failedWithError:)];
}}}
Service objects maintain cookies and track data modification dates to minimize server loads, so it's best to reuse a service object for sequences of server requests.

The application may choose to retain the ticket following the fetch call so the user can cancel the service request.  The ticket is valid so long as the application retains it.
To cancel a fetch in progress, call `[ticket cancelTicket]`.  Once the finished or failed callback has been called, the ticket is no longer useful and may be released.

Here is what the callback from a successful fetch of the calendar list might look like.  This callback example just prints the title of the user's first calendar.
{{{
- (void)ticket:(GDataServiceTicket *)ticket
finishedWithFeed:(GDataFeedCalendar *)feed {
  
  if ([[feed entries] count] > 0) {

    GDataEntryCalendar *firstCalendar = [[feed entries] objectAtIndex:0];
    GDataTextConstruct *titleTextConstruct = [firstCalendar title];
    NSString *title = [titleTextConstruct stringValue];
    
    NSLog(@"first calendar's title:%@", title);
  }
}
}}}

Service objects include a variety of methods for interacting with the service. Typically, the interactions include some or all of these activities:
  * fetching a feed
  * inserting an entry into a feed
  * updating (replacing) an entry in a feed
  * deleting an entry or a feed
  * performing queries to obtain a subset of the feed's entries
  * performing a [http://code.google.com/apis/gdata/batch.html batch operation] of inserting, updating, and deleting entries

Feeds and entries typically contain *links* to themselves or to other objects. For example, to retrieve the events for a user's calendar, use a Calendar service object to fetch from the Calendar's "alternate" link:

{{{
    NSArray *entryLinks = [firstCalendar links];
    GDataLink *link = [entryLinks alternateLink];
    NSURL* linkURL = [link URL];

    if (linkURL != nil) {
      [service fetchCalendarEventFeedWithURL:linkURL
                                    delegate:self
                           didFinishSelector:@selector(eventsTicket:finishedWithEntries:)
                             didFailSelector:@selector(eventsTicket:failedWithError:)];
    }
}}}

GData provides convenience categories on NSArray for retrieving individual links, as the example above shows in retrieving the "alt" link from the entry's array of links.  

A particularly important link is the *next link*; it is present when the feed contains only a partial set of results from the request.  If the feed's `[links nextLink]` is present, the client application must perform a new request using the "next" link URL to retrieve additional entries.

Service-specific *query* objects can generate URLs with parameters appropriate for restricting a feed's entries. For example, a query could request a feed of Calendar events between specific dates, or of database items of a specified category.  Here is an example of a query to retrieve the first 5 events from a user's calendar:
{{{
- (void)beginFetchingFiveEventsFromCalendar:(GDataEntryCalendar *)calendar {
    
  NSURL *feedURL = [[[calendar links] alternateLink] URL];
  
  GDataQueryCalendar* queryCal = [GDataQueryCalendar calendarQueryWithFeedURL:feedURL];
  [queryCal setStartIndex:1];
  [queryCal setMaxResults:5];
  
  GDataServiceGoogleCalendar *service = [self calendarService];
  [service fetchCalendarQuery:queryCal
                     delegate:self
            didFinishSelector:@selector(queryTicket:finishedWithEntries:)
              didFailSelector:@selector(queryTicket:failedWithError:)];
}
}}}


== Creating GDataObjects from scratch ==

Typically GDataObjects are created by the framework from XML returned from a server, but occasionally it is useful to create one from scratch.  This snippet shows how to create a new event to add to a user's calendar:
{{{
- (void)addAnEventToCalendar:(GDataEntryCalendar *)calendar {
  
  // make a new event
  GDataEntryCalendarEvent *newEvent = [GDataEntryCalendarEvent calendarEvent];
  
  // set a title, description, and author
  [newEvent setTitleWithString:@"Meeting"];
  [newEvent setSummaryWithString:@"Today's discussion"];

  GDataPerson *authorPerson = [GDataPerson personWithName:@"Fred Flintstone"
                                                    email:@"fred.flinstone@spurious.xxx.com"];
  [newEvent addAuthor:authorPerson];
  
  // start time now, end time in an hour
  NSDate *anHourFromNow = [NSDate dateWithTimeIntervalSinceNow:60*60];
  GDataDateTime *startDateTime = [GDataDateTime dateTimeWithDate:[NSDate date]
                                                        timeZone:[NSTimeZone systemTimeZone]];
  GDataDateTime *endDateTime = [GDataDateTime dateTimeWithDate:anHourFromNow
                                                      timeZone:[NSTimeZone systemTimeZone]];

  // reminder 10 minutes before the event
  GDataReminder *reminder = [GDataReminder reminder];
  [reminder setMinutes:@"10"];
  
  GDataWhen *when = [GDataWhen whenWithStartTime:startDateTime
                                         endTime:endDateTime];
  [when addReminders:reminder];

  [newEvent addTime:when];  

  // add it to the user's calendar
  NSURL *feedURL = [[[calendar links] alternateLink] URL];
 
  GDataServiceGoogleCalendar *service = [self calendarService];
  [service fetchCalendarEventByInsertingEntry:newEvent
                                   forFeedURL:feedURL
                                     delegate:self
                            didFinishSelector:@selector(addTicket:addedEntry:)
                              didFailSelector:@selector(addTicket:failedWithError:)];
}
}}}

== Adding custom data to GDataObject instances ==

Your application can add data to any instance of a GDataObject (such as entry and feed objects, as well as individual elements) in three ways.

Each GDataObject has methods `setUserData:` and `userData` to set and retrieve a single NSObject.

An application can set and retrieve objects as named properties of any GDataObject instance with the methods `setProperty:forKey:` and `propertyForKey:`.  Note that property names beginning with an underscore are reserved by the library and should not be used by applications.

Finally, applications may subclass GDataObjects to add fields and methods.  To have your subclasses be instantiated in place of the standard object class during the parsing of XML following a fetch, call `setServiceSurrogates:`, as demonstrated here:

{{{
NSDictionary *surrogates = [NSDictionary dictionaryWithObjectsAndKeys:
  [MyEntryPhoto class], [GDataEntryPhoto class],
  [MyEntryAlbum class], [GDataEntryPhotoAlbum class],
  nil];

service = [[GDataServiceGooglePicasaWeb alloc] init];
[service setServiceSurrogates:surrogates];
}}}

== Uploading files ==

Some services allow uploading of a file when inserting an entry into a feed.  Uploading requires setting the upload data and MIME type in the entry. Some services also require a *slug* as the file name.  

This snippet shows the basic steps for uploading a spreadsheet document.

{{{
GDataEntrySpreadsheetDoc *newEntry = [GDataEntrySpreadsheetDoc documentEntry];
  
NSString *path = @"/mySpreadsheet.xls";
NSData *data = [NSData dataWithContentsOfFile:path];
if (data) {
  NSString *fileName = [path lastPathComponent];
  
  [newEntry setUploadSlug:filename];
  [newEntry setUploadData:data];
  [newEntry setUploadMIMEType:@"application/vnd.ms-excel"];

  NSString *title = [[NSFileManager defaultManager] displayNameAtPath:path];
  [newEntry setTitleWithString:title];
  
  NSURL *postURL = [[[docListFeed links] postLink] URL];

  ticket = [service fetchDocEntryByInsertingEntry:newEntry
                                       forFeedURL:postURL
                                         delegate:self
                                didFinishSelector:finishedSel
                                  didFailSelector:failedSel];
}
}}}

== Upload progress monitoring ==

When uploading large blocks of data, such as photos, your application can request periodic callbacks to update a progress indicator.  To receive the callback, set an upload progress selector in the service, such as:

{{{
SEL progressSel = @selector(inputStream:hasDeliveredByteCount:ofTotalByteCount:);
[service setServiceUploadProgressSelector:progressSel];

// then do the fetch
//   GDataServiceTicket *ticket = [service fetch...];

// If future tickets should not use the progress callback, 
// set the selector in the service back to nil

[service setServiceUploadProgressSelector:nil];
}}}

The callback is a method with a signature matching this:
{{{
- (void)inputStream:(GDataProgressMonitorInputStream *)stream 
   hasDeliveredByteCount:(unsigned long long)numberOfBytesRead 
   ofTotalByteCount:(unsigned long long)dataLength {

  // The progress method can obtain the ticket by 
  // calling [stream monitorSource];
}
}}}

== Status 304 and service data caching ==

GData servers provide a "Last-Modified" header with their responses.  The service object remembers the header, and provides it as an "If-Modified-Since" request the next time the application makes a request to the same URL.  If the request would have the same response as it did previously, the server returns no data to the second request, just status 304, "Not modified". 

Your service delegate will see the "Not modified" response in its `ticket:failedWithError:` method.  The application handles it like this:

{{{
- (void)ticket:(GDataServiceTicket *)ticket failedWithError:(NSError *)error {
  if ([error code] == kGDataHTTPFetcherStatusNotModified) { // status 304
    // no change since previous request
  } else {
    // some unexpected error occurred
  }
}
}}}

The service can optionally remember the dated responses in a cache and provide them to the application instead of calling the failure method.  To enable the caching, the application should call
{{{
[service setShouldCacheDatedData:YES];
}}}

The service will thereafter call the delegate's service:fetcher:finishedWithObject: method with duplicates of the original response rather than call the failure method with a status 304 error.  You can call `[service clearLastModifiedDates]` to purge the cache, or `[service setShouldCacheDatedData:NO]` to purge and disable the future caching.

== Authentication errors and captchas ==

[http://code.google.com/apis/gdata/auth.html Authenticating] the user with Google's services is handled mostly transparently by the framework.  If your application sends the  `setUserCredentialsWithUsername:password:` message to the service object, the service object will sign in prior to fetching the requested object.

The most common authentication error is an invalid username or password.  Occasionally, the servers may also request that the user solve a [http://www.captcha.net/ captcha], a visual puzzle.

It is optional for your application to handle captcha requests. One easy way to handle them is to just open the Google's unlock captcha web page in the user's web browser.

{{{
NSURL *captchaUnlockURL = [NSURL URLWithString:@"https://www.google.com/accounts/DisplayUnlockCaptcha"];
[[NSWorkspace sharedWorkspace] openURL:captchaUnlockURL];
}}}

For the best user experience in handling captcha requests, your application can download and display the captcha image to the user, and wait for the user to provide the answer. If the user offers an answer, put the captcha token and the user's answer into the service object with `setCaptchaToken:captchaAnswer:`, and retry the fetch.

To handle captchas, the fetch failed method might look something like this:

{{{
- (void)ticket:(GDataServiceTicket *)ticket failedWithError:(NSError *)error {
  
  if ([error code] == kGDataBadAuthentication) {
    
    NSDictionary *userInfo = [error userInfo];
    NSString *authError = [userInfo authenticationError];
    
    if ([authError isEqual:kGDataServiceErrorCaptchaRequired]) {
  
      // URL for a captcha image (200x70 pixels)

      NSURL *captchaURL = [userInfo captchaURL];
      NSString *captchaToken = [userInfo captchaToken];
      
      // a synchronous read of the image is simple, as shown here,
      // but to be nice to users, you can use GDataHTTPFetcher for
      // an easy asynchronous fetch of the data instead

      NSData *imageData = [NSData dataWithContentsOfURL:captchaURL];
      if (imageData) {
        NSImage *image = [[[NSImage alloc] initWithData:imageData] autorelease];
 
        [self askUserToSolveCaptchaImage:image 
                               withToken:captchaToken];

        // pass the token and user's captcha answer later to the service, like
        //   [service setCaptchaToken:captchaToken captchaAnswer:theUserAnswer]
        // prior to retrying the fetch
     }
    } else {
      // invalid username or password
    }
  } else {
    // some other error authenticating or retrieving the GData object
    // or a 304 status indicating the data has not been modified since it
    // was previously fetched
  }
}
}}}

_Tip_: to force a captcha request from the server for testing, provide an invalid e-mail address as the username several times in a row.

Documentation on authentication for Google data APIs is available [http://code.google.com/apis/gdata/auth.html here].

== Proxy Authentication ==

In corporate or institutional settings where a password-protected proxy is in use, a proxy error may show up in the failure callback.  It would have constant error domain and code values, as shown here:
{{{
- (void)fetchTicket:(GDataServiceTicket *)ticket
    failedWithError:(NSError *)error {
  
  if ([error code] == kGDataHTTPFetcherErrorAuthenticationChallengeFailed
      && [[error domain] isEqual:kGDataHTTPFetcherErrorDomain]) {

    NSURLAuthenticationChallenge *challenge;
    challenge = [[error userInfo] objectForKey:kGDataHTTPFetcherErrorChallengeKey];
  }
  ...
}
}}}
If you want to handle such errors, use the
challenge object to display a dialog showing information about the host and requesting
account and password credentials for the proxy.  The proxy credentials can then
be passed to the ticket's authentication fetcher:
{{{
ticket = [service fetchFeed...];
if (proxyAccountName && proxyPassword) {
  NSURLCredential *cred;
  cred = [NSURLCredential credentialWithUser:proxyAccountName
                                    password:proxyPassword
                                 persistence:NSURLCredentialPersistencePermanent];
  [[ticket authFetcher] setProxyCredential:cred];
}
}}}

== Logging http server traffic ==

Debugging GData transactions is often easier when you can browse the XML being sent back and forth over the network.  To make this convenient, the framework can save copies of the server traffic, including http headers, to files in a local directory.  Your application should call

{{{
[GDataHTTPFetcher setIsLoggingEnabled:YES]
}}}

to turn on logging.  Normally, logs are written to the directory GDataHTTPDebugLogs in the current user's Desktop folder, though the path to another folder can be specified with the `+setLoggingDirectory:` method.

To view the most recently saved logs, use a web browser to open the symlink named !My_App_Name_http_log_newest.html (for whatever your application's name is) in the logging directory.  Note that Camino and Firefox display XML in a more useful fashion than does Safari.